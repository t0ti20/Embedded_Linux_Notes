# To Add
You ask three questions, so I will try to answer each of them.

- Can someone give me an example of where **only** `static_assert` will work, or **only** `assert`?

`static_assert` is good for testing logic in your code at compilation time. `assert` is good for checking a case during run-time that you expect should always have one result, but perhaps could somehow produce an unexpected result under unanticipated circumstances. For example, you should only use `assert` for determining if a pointer passed into a method is `null` when it seems like that should never occur. `static_assert` would not catch that.

- Do they do anything a simple `if` statement can't do?

`assert` can be used to break program execution, so you could use an `if`, an appropriate error message, and then halt program execution to get a similar effect, but `assert` is a bit simpler for that case. `static_assert` is of course only valid for compilation problem detection while an `if` must be programmatically valid and can't evaluate the same expectations at compile-time. (An `if` can be used to spit out an error message at run-time, however.)

- Is it bad practice to use them?

Not at all!
# Operators
## Operator Types

```CPP
# Arithmetic Operators
a + b;
# Assignment Operators
a = 5;
# Relational Operators
a > b;
# Logical Operators
(a>b)&&(a>10);
# Bitwise Operators
a&1;
# Other Operators
sizeof
?:
&
.
->
>>
<<
```
## Operator Overloading
### Using Class

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    string Name{"Default Name"};
    Dog operator+(const Dog &Dog_2) const
    {
        return Dog(Name+" & "+Dog_2.Name);
    }
};
int main()
{
    unique_ptr<Dog> Dog_1{new Dog("Dog 1")};
    unique_ptr<Dog> Dog_2{new Dog("Dog 2")};
    unique_ptr<Dog> Dog_3{new Dog((*Dog_1)+(*Dog_2))};
    Dog_1->Print_Name();
    Dog_2->Print_Name();
    Dog_3->Print_Name();
    return 0;
}
```
### Using Two Parameters

```CPP
//////////////////////////////////////////////////
void operator+(uint32_t &Number,const string &Name)
{
    for(size_t Counter{};Counter<Name.size();Counter++)
    {
        Number=Number*10+(Name[Counter]-'a');
    }
}
int main (int argc,char *argv[])
{
    uint32_t Number{};
    string Name{"abcdefg"};
    Number+Name;
    cout<<Number<<endl;
    return 0;
}
//////////////////////////////////////////////////
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
	friend Dog operator+(const Dog &Dog_1,const Dog &Dog_2);
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    string Name{"Default Name"};
};
Dog operator+(const Dog &Dog_1,const Dog &Dog_2)
{
    return Dog(Dog_1.Name+" + "+Dog_2.Name);
}
int main()
{
    unique_ptr<Dog> Dog_1{new Dog("Dog 1")};
    unique_ptr<Dog> Dog_2{new Dog("Dog 2")};
    unique_ptr<Dog> Dog_3{new Dog((*Dog_1)+(*Dog_2))};
    Dog Dog_4{};
    Dog_4=operator+((*Dog_1),(*Dog_2));
    Dog_1->Print_Name();
    Dog_2->Print_Name();
    Dog_3->Print_Name();
    Dog_4.Print_Name();
    return 0;
}
//////////////////////////////////////////////////
```

### Subscript Operator

```cpp
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Nme):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    char operator[](const size_t Index)const
    {
    	   assert(Index<Name.size()&&"Index out of bounds");
        return Name[Index];
    }
private:
    string Name{"Default Name"};
};
int main()
{
    Dog Dog_1{"Dog 1"};
    cout<<Dog_1[0]<<endl;
    cout<<Dog_1.operator[](1)<<endl;
    return 0;
}
//////////////////////////////////////////////////////
#include <cassert>
#include <iostream>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Nme):Name{Dog_Name}     
        {cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    char& operator[](const size_t Index)
    {
        assert(Index<Name.size()&&"Index out of bounds");
        return Name[Index];
    }
private:
    string Name{"Default Name"};
};
int main()
{
    Dog Dog_1{"Dog 1"};
    Dog_1[4]='2';
    Dog_1.Print_Name();
    return 0;
}
```

### Insertion Operator

```cpp
#include <cassert>
#include <iostream>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    ostream& operator<<(ostream& Stream)
    {
        Stream<<Name<<endl;
        return Stream;
    }
private:
    friend ostream& operator<<(ostream& Stream,Dog &Dog_Object);
    string Name{"Default Name"};
};
ostream& operator<<(ostream& Stream,Dog &Dog_Object)
{
    Stream<<Dog_Object.Name;
}
int main()
{
    Dog Dog_1{"Dog 1"};
    Dog_1.Print_Name();
    Dog_1<<cout;
    cout<<Dog_1<<endl;
    return 0;
}
```
### Extraction Operator

```cpp
#include <cassert>
#include <iostream>
using namespace std;
class Dog
{
public:
    Dog()=delete;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    friend istream& operator>>(istream &Input_Stream,Dog& Dog_Object);
    string Name{"Default Name"};
};
istream& operator>>(istream &Input_Stream,Dog& Dog_Object)
{
    cout<<"Please Enter Dog Name : ";
    Input_Stream>>Dog_Object.Name;
    return Input_Stream;
}
int main()
{
    Dog Dog_1{"Default"};
    cin>>Dog_1;
    Dog_1.Print_Name();
    return 0

}
```
### Custom Type Conversion

```cpp
#include <iostream>
using namespace std;
class Dog
{
public:
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    operator string()const{return Name;}
    operator int()const{return (Name[5]-'0');}
private:
    string Name{"Default Name"};
};
int main()
{
    Dog Dog_1{"Dog (1)"};
    Dog Dog_2{"Dog (2)"};
    string Both{string(Dog_1)};
    Both+=string(Dog_2);
    int Sum{Dog_1+Dog_2};
    cout<<Both<<endl;//Dog (1)Dog (2)
    cout<<Sum<<endl;//3
    return 0;
}
```


### Prefix and Postfix

```cpp
#include <iostream>
using namespace std;
class Dog
{
public:
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    friend void operator++(Dog &Object);
    string Name{"Default Name"};
};
void operator++(Dog &Object){Object.Name[5]++;}
int main()
{
    Dog Dog_1{"Dog (1)"};
    Dog Dog_2{"Dog (2)"};
    ++Dog_1;
    Dog_1.Print_Name();
    return 0;
}
////////////////////////////////////////////////////////////////
#include <iostream>
using namespace std;
class Dog
{
public:
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    Dog operator++(int)
    {
        Dog Return{*this};
        ++(*this);
        return Return;
    };
private:
    friend const Dog& operator<<(ostream &Output,const Dog &Object);
    friend Dog& operator++(Dog &Object);
    string Name{"Default Name"};
};
const Dog& operator<<(ostream &Output,const Dog &Object)
{
    Output<<Object.Name<<endl;
    return Object;
}
Dog& operator++(Dog &Object){Object.Name[5]++;return Object;}
int main()
{
    Dog Dog_1{"Dog (1)"};
    cout<<++Dog_1;
    Dog_1.Print_Name();
    cout<<Dog_1++;
    Dog_1.Print_Name();
    return 0;
}
```
### Assignment Operator Overloading

```cpp
#include <iostream>
using namespace std;
class Point
{
public:
	Point(int X,int Y):X_Axis{X},Y_Axis{Y},Summation{new int (X+Y)}{cout<<"Constructor"<<endl;}
	~Point(){delete Summation;cout<<"Distructor"<<endl;}
	Point& operator=(Point &Object)
	{
		if(this!=&Object)
		{
			cout<<"Assign Operator Overloading"<<endl;
			this->X_Axis=Object.X_Axis;
			this->Y_Axis=Object.Y_Axis;
			*this->Summation=*Object.Summation;
		}
		return *this;
	}
	Point(const Point &Object)
	{
		if(this!=&Object)
		{
			cout<<"Copy Constructor"<<endl;
			this->X_Axis=Object.X_Axis;
			this->Y_Axis=Object.Y_Axis;
			this->Summation=new int(*Object.Summation);
		}
	}
	int X_Axis{};
	int Y_Axis{};
	int *Summation{};
};
ostream& operator<<(ostream &Stream,Point const &Object)
{
	Stream<<'('<<Object.X_Axis<<','<<Object.Y_Axis<<')'<<"->"<<(*Object.Summation);
	return Stream;
}
int main() 
{
	Point P1{10,10};//Constructor
	Point P2{P1};//Copy Constructor
	P1.X_Axis=200;
	cout<<P1<<endl<<P2<<endl;//(200,10)->20\n(10,10)->20
	P2=P1;//Assign Operator Overloading
	*P2.Summation=100;
	cout<<P1<<endl<<P2<<endl;//(200,10)->20\n(200,10)->100
	return 0;//Distructor\nDistructor
}

```
# Strings (std::string)
## Declaring and Using 

```cpp
#include<string>
//Empty String
std::string Name;
//Initialized
std::string Name{"My Name"};
//Part Of Strring
std::string Name{"My Name",4};
//Repeat Character
std::string Name{'A',4}
//Range
std::string Name{"Hello World",2,6};
```

## Concatenating

```cpp
#include<string>
std::string Name_1{"My Name"};
std::string Name_2{" Is Khaled"};
// + Operator
std::string Name{Name_1+Name_2};
//Append
Name_1.append(Name_2);
```

## Accessing Characters

```cpp
#include<string>
std::string Name{"This Is My String."};
// size Function
for(size_t Counter{};Counter<Name.size();Counter++)
{
	std::cout<<Name[Counter]<<std::endl;//Name.at(Counter)
}
// front and back
 char &Front=Name.front();
 char &Back=Name.back();
 Front='t';
 Back='!';
 cout<<Name<<endl;
 // Pointer
 std::string Name{"This Is My String."};
 char *Name_Ptr=Name.data();
 cout<<Name_Ptr<<endl;
```
## Size and Capacity

```cpp
#include<string>
std::string Name{"This Is My String."};
std::string No_Name{};
// empty Function
cout<<Name.empty()<<endl;
cout<<No_Name.empty()<<endl;
// size function
cout<<No_Name.size()<<endl;
cout<<Name.size()<<endl;
// length function
cout<<No_Name.length()<<endl;
cout<<Name.length()<<endl;
// max number
cout<<std::string::max_size()<<endl;
cout<<std::Name.capacity()<<endl;
// extend size
Name.reserve(<bytes>);
// reduce string
Name.shrink_to_fit(<bytes>);
```

## Modifying

```cpp
#include<string>
std::string Name{"This Is My String."};
// insert string
Name.insert(4," Hello");
Name.insert(4,1,'H');
Name.insert(4," Hello World",6);
// erase string
Name.erase(4,Name.size());
// empty string
Name.clear();
std::cout<<Name<<std::endl;
// push - pop
Name.push_back('!');
Name.pop_back();
```
## Comparing

```cpp
#include<string>
std::string Number_1{"Number 1"};
std::string Number_2{"Number 2"};
// operator
if(Number_1>Number_2)cout<<"True"<<endl;
else cout<<"False"<<endl;
// compare
if(Number_1.compare(0,6,Number_2,0,6)==0)cout<<"True"<<endl;
else cout<<"False"<<endl;
```

## Common Operations

```cpp
#include<string>
std::string Number{"Number 1"};
// Replacing
Number.replace(7,8,"2");
// copy
char Array[10]{};
Number.copy(Array,1,7);
cout<<Array<<endl;
// resize
Number.resize(10,'!');
Number.resize(6);
cout<<Number<<endl;
// swap
std::string Number_1{"Number 1"};
std::string Number_2{"Number 2"};
Number_1.swap(Number_2);
cout<<Number_1<<endl;
```

## Searching

```cpp
#include<string>
std::string Number{"The Number Is 1"};
// find
cout << Number.find("Is") << endl;
cout << Number.find("The",2) << endl;
```

## Numbers Transforming

```cpp
#include<string>
std::string Number_String{};
int Number{100};
// to_string
Number_String=to_string(Number);
cout << Number_String << endl;
// sto<type>
Number=stoi(Number_String);
cout << Number_String << endl;
```

## Raw String Literals

```cpp
#include<string>
std::string String
{
  R"<delimiter>(  1-Hello!
  2-Hello/
  3-Hello*
  4-Hello
  )<delimiter>"
};
cout<<String<<endl;
```



## String View

```cpp
#include<string>
std::string Name{"This Is My Name !"};
std::string_view Name_View{Name};
//remove_prefix
Name_View.remove_prefix(1);
//remove_suffix
Name_View.remove_suffix(1);
std::cout<<Name_View<<std::endl;
```





















___
# Functions
## Pass By Reference

```cpp
// & Operaot
void Modify_Number(int &Number){Number++;}
int main()
{
  int x{9};
  Modify_Number(x);
  cout << x << endl;
  return 0;
}
// Pointer
// Array
void Modify_Number(int (&Array)[4],int Size)
{
	for(size_t Counter{};Counter<Size;++Counter)
	{
		Array[Counter]++;
	}
}
int main()
{
  int x[]{10,20,30,40};
  Modify_Number(x,4);
  cout << x[1] << endl<< x[2] << endl<< x[3] << endl;
  return 0;
}
// & And Cast
void Modify_Number(const int &Number){cout << x << endl;}
int main()
{
  double x{9};
  Modify_Number(x);//Id Const Not Exist Will Fail
  return 0;
}
```
## Constrexpr

```CPP
constexpr int Power(constexpr int Number)
{
	return (Number*Number);
}
int main ()
{
	constexpr int Number = Power(2);
	std::cout<<Number<<std::endl;
	return 0;
}
```
## Consteval

```CPP
consteval int Power(int Number)
{
	return (Number*Number);
}
int main ()
{
	constexpr int Number = Power(2);
	std::cout<<Number<<std::endl;
	return 0;
}
```
## Main Arguments 

```cpp
int main (int argc,char *argv[])
{
    for(size_t Counter{};Counter<argc;++Counter)
    {
        cout<<argv[Counter]<<std::endl;
    }
    return 0;
}
```
## Return By Reference
```cpp
int &Maximun_Number(int &First_Number,int &Second_Number)
{
    return (First_Number>Second_Number)?First_Number:Second_Number;
    //static int result =(First_Number>Second_Number)?First_Number:Second_Number;
    //return result;
}
int main (int argc,char *argv[])
{

    int First_Number{10},Second_Number{20};
    int Result{Maximun_Number(First_Number,Second_Number)};
    cout<<Result<<std::endl;
    return 0;
}
```
## Function Overloading

```cpp
#include <array>
void Print_Name(string Name_1){cout<<Name_1<<endl;}
void Print_Name(string Name_1,string Name_2){cout<<Name_1<<' '<<Name_2<<endl;}
int main (int argc,char *argv[])
{
    Print_Name("Hello World");
    Print_Name("Hello","World");
    return 0;
}
```
## Optional Output

```cpp
#include <optional>
using namespace std;
int main (int argc,char *argv[])
{
    optional<int> Age{3};
    optional<string> Name{"Ahmed"};
    optional<bool> Gender{nullopt};
    cout<<(Age.has_value()?Age.value():-1)<<endl;
    cout<<static_cast<string>(Name.has_value()?Name.value():"")<<endl;
    cout<<(Gender.has_value()?Gender.value():-1)<<endl;
    return 0;
}
#--------------------------------------------------------------
optional<size_t> Get_Char(const string &Name,optional<char> Char)
{
    optional<size_t>Result{nullopt};
    char Searching_For{Char.value_or('!')};
    for(size_t Counter{};Counter<Name.size();++Counter)
    {
        if(Searching_For==Name[Counter])Result=Counter;
    }
    return Result;
}
int main (int argc,char *argv[])
{
    string Name{"Hello World!"};
    optional<size_t> Result=Get_Char(Name,'A');
    cout<<static_cast<int>(Result.has_value()?Result.value():-1)<<endl;
    return 0;
}
```
## Function Overloading

```cpp
uint32_t Max(uint32_t Number_1,double Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
uint32_t Max(double Number_2,uint32_t Number_1)
{
    return Number_1>Number_2?Number_1:Number_2;
}
int main (int argc,char *argv[])
{
    cout<<Max(10.10,9)<<endl;
    return 0;
}
```
## Lambda Function 

```cpp
int main (int argc,char *argv[])
{
    auto Function=[](uint32_t Numper_1,uint32_t Numper_2)->uint32_t
    {
        return (Numper_1+Numper_2);
    };
    cout<<Function(10,20)<<endl;
    return 0;
}
//----------------------------------------------------
uint32_t Number_1{20};
uint32_t Number_2{30};
int main (int argc,char *argv[])
{
    uint32_t Number_1{10};
    uint32_t Number_2{10};
    auto Function=[Number_1,Number_2]()->uint32_t
    {
        return (Number_1+Number_2);
    };
    cout<<Function()<<endl;
    return 0;
}
//------------------------------------------------------
// & Reference -- = Value
int main (int argc,char *argv[])
{
    uint32_t Number_1{10};
    uint32_t Number_2{10};
    auto Function=[&]()->uint32_t
    {
        ++Number_1;++Number_2;
        return (Number_1+Number_2);
    };
    cout<<Function()<<endl;
    cout<<Function()<<endl;
    return 0;
}
```
## Inline Functions

```CPP
/*
**Definition in Header Files**: Typically, inline functions are defined in header files because the compiler needs to see the function body when it's compiling the call site. If the function is defined in a separate source file, the compiler may not be able to inline it.

**Small Functions**: `inline` is most effective for small, frequently-called functions. If a function is too large or complex, the overhead of inlining may outweigh the benefits.

**Multiple Definitions**: If an `inline` function is defined in multiple translation units (source files), each definition must be identical. This means it's usually defined in the header file to ensure consistency across translation units.

**Linkage**: `inline` functions have internal linkage by default, meaning they are not visible outside the translation unit. If you want an `inline` function to be externally visible, you may need to explicitly declare it as `extern inline`.
*/

inline int Add(int Number_1,int Number_2)
{
    return (Number_1+Number_2);
}
int main (int argc,char *argv[])
{
    cout<<Add(10,20)<<endl;
    return 0;
}
```
## Function Templates

```cpp
template<typename Type> Type Greater(Type Number_1,Type Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
template<> const char* Greater<const char*>(const char* String_1,const char* String_2)
{
    return (std::strcmp(String_1,String_2)>0)?String_1:String_2;
}
template<typename Return> Return* ARRAY(size_t Size)
{
    Return* Array = new Return[Size];
    return Array;
}
###############################################
#->decltype()
template<typename Type_1,typename Type_2> auto Maximum(Type_1 Number_1,Type_2 Number_2)->decltype((Number_1>Number_2)?Number_1:Number_2);
int main()
{
    auto Return{Maximum(100,20.1)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
template<typename Type_1,typename Type_2> auto Maximum(Type_1 Number_1,Type_2 Number_2)->decltype((Number_1>Number_2)?Number_1:Number_2)
{
    return (Number_1>Number_2)?Number_1:Number_2;
}
###############################################
#decltype(auto)
template<typename Type_1,typename Type_2>
decltype(auto)Maximum(Type_1 Number_1,Type_2 Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
int main()
{
    auto Return{Maximum(100,20.1)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
###############################################
#Default Arguments
template<typename Return=double,typename Type_1,typename Type_2>
Return Maximum(Type_1 Number_1,Type_2 Number_2)
{
    return Number_1>Number_2?Number_1:Number_2;
}
int main()
{
    auto Return{Maximum<int>(100,20.1f)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
###############################################
#Non Type Parameters
template<int Maximum_Value,typename Return=double,typename Type_1,typename Type_2>
Return Maximum(Type_1 Number_1,Type_2 Number_2)
{
return ((Number_1>Number_2?Number_1:Number_2)>Maximum_Value)?Maximum_Value:(Number_1>Number_2?Number_1:Number_2);
}
int main()
{
    auto Return{Maximum<100,int>(99,20.1f)};
    std::cout<<Return<<"--"<<sizeof(Return)<<std::endl;
    return 0;
}
###############################################
#Lamda Function With Auto Template
int main()
{
    std::cout<<
    [] <typename Type_1,typename Type_2> (Type_1 Number_1,Type_2 Number_2)
    {
        return Number_1+Number_2;
    }(10.1,29)
    <<std::endl;
    return 0;
}
###############################################
main()
{
	std::cout << std::boolalpha;
	SHOW(std::is_integral<A>::value);
	SHOW(std::is_integral_v<E>);
	SHOW(std::is_integral_v<float>);
	SHOW(std::is_integral_v<int*>);
}
###############################################
template<typename T>
auto get_value(T t)
{
    if constexpr ([std::is_pointer_v](std::is_pointer_v<T>)
        return *t; // deduces return type to int for T = int*
    else
        return t;  // deduces return type to int for T = int
}
			   
```
## Concepts <mark style="background: #FF5582A6;">(C++20)</mark>

```CPP
######################################
#Default Concepts
######################################
template <typename Type>
requires std::is_floating_point_v<Type>
Type Add(Type n1,Type n2)
{
    return n1+n2;
}
######################################
template <std::integral Type>
Type Add(Type n1,Type n2)
{
    return n1+n2;
}
######################################
auto Add(std::integral auto n1,std::integral auto n2)
{
    return n1+n2;
}
######################################
int main()
{
    cout<<Add(10.10,20.1)<<endl;
    return 0;
}
######################################
#Custom Concepts
######################################
template <typename Type>
concept My_Restrictions=is_floating_point_v<Type>;
template <typename Type>
Type Add(Type n1,Type n2) requires My_Restrictions<Type>
{
    return n1+n2;
}
int main()
{
    cout<<Add(10.10,20.1)<<endl;
    return 0;
}
```
## Friend Function

```cpp
#include <iostream>
struct Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{}
private:
    double m_y{};
    double m_x{};
    friend void Print(const Point &X);
    friend void Print_y(const Point &X);//NoErrors
};
void Print(const Point &X){std::cout<<"["<<X.m_x<<","<<X.m_y<<"]"<<std::endl;}
int main()
{
    Point X{1,2};
    Print(X);
    return 0;
}
//////////////////////////////////////////////////////////
#include <iostream>
class Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{}
private:
    double m_y{};
    double m_x{};
    friend class Print;
};
class Print
{
public:
    void Print_Point(const Point &X){std::cout<<"["<<X.m_x<<","<<X.m_y<<"]"<<std::endl;}
};
int main()
{
    Point X{1,2};
    Print P;
    P.Print_Point(X);
    return 0;
}
```
# Enum & Type Alias
## Enum Class

```cpp
enum class MONTH : unsigned char
{
	JAN,FEP=254,MAR,
};
int main ()
{
	unsigned int Register=3'000'000'000;
	MONTH x=MONTH::MAR;
	std::cout << static_cast<int>(x) << std::endl;
	using enum MONTH
	MONTH x=MAR;
	std::cout << static_cast<int>(x) << std::endl;
	return 0;
}
```

## Type Alias

```cpp
using Number=unsigned int;
int main ()
{
    Number x=123;
    std::cout << x << std::endl;
    return 0;
}
```

# Classes
## Constrictors

```CPP
class Point
{
	private:
		   double m_x{1};
	        double m_y{1};
	public:
		Point():m_x{2},m_y{2}{};
		double distance_to(Point &Second_Point)
		{
		  return sqrt((m_x-Second_Point.m_x)*(m_x-Second_Point.m_x)+(m_y-Second_Point.m_y)*(m_y-Second_Point.m_y));
		}
};
#Default Constractor
class Point
{
	private:
		   double m_x{1};
	        double m_y{1};
	public:
		Point()=default; //If Not Exist Error Point x();
		Point(double x,double y):m_x{x},m_y{y}{};
		double distance_to(Point &Second_Point)
		{
		  return sqrt((m_x-Second_Point.m_x)*(m_x-Second_Point.m_x)+(m_y-Second_Point.m_y)*(m_y-Second_Point.m_y));
		}
};
```
## Pointers

```cpp
#include<iostream>
constexpr const double PI{3.14};
class Cylinder
{
    private:
        double Radius{1};
        double Height{1};
    public:
        double Volume(){return Radius*Radius*PI*Height;}
};
using namespace std;
int main(int, char*[])
{
    Cylinder C1{},*P_C1=&C1,&R_C1{C1};
    cout<<C1.Volume()<<endl;
    cout<<P_C1->Volume()<<endl;
    cout<<(*P_C1).Volume()<<endl;
    cout<<R_C1.Volume()<<endl;
#Test (Valid But Cant Delete It)
    Cylinder &P_C1=*(new Cylinder{});
    cout<<P_C1.Volume()<<endl;
    //delete P_C1;
    return 0;
}
######################################################
#This Pointer
template <typename Type>
Common& operator<<(Type& Message)
{
     switch (Current_Color)
     {
          case Console_Color::Default:
               std::cout<<Message;
          break;
          case Console_Color::Yellow:
               std::cout << "\033[1;33m" << Message << "\033[0m";
          break;
          case Console_Color::Blue:
               std::cout << "\033[1;34m" << Message << "\033[0m";
          break;
          case Console_Color::Red:
               std::cout << "\033[1;31m" << Message << "\033[0m";
          break;
          case Console_Color::Green:
               std::cout << "\033[1;32m" << Message << "\033[0m";
          break;
     }
     Current_Color=Console_Color::Default;
     return *this;
}
######################################################
```
## Constant

```cpp
#include<iostream>
constexpr const double PI{3.14};
using namespace std;
class Cylinder
{
    private:
        double Radius{1};
        double Height{1};
    public:
        double Volume()const{return Radius*Radius*PI*Height;}
        Cylinder(){cout<<"Constructor"<<endl;}
        ~Cylinder(){cout<<"Distructor"<<endl;}
};
const Cylinder C1{};
void Test(Cylinder Temp)
{
    cout<<Temp.Volume()<<endl;
}
int main(int, char*[])
{
    const Cylinder &P_C1=C1;
    Cylinder C2=C1;
    cout<<C1.Volume()<<endl;
    cout<<C2.Volume()<<endl;
    Test(C1);
    return 0;
}
###########################################################
#include<iostream>
constexpr const double PI{3.14};
using namespace std;
class Cylinder
{
    private:
        mutable double Radius{1};
        mutable double Height{1};
    public:
        double Volume()const{return Radius*Radius*PI*Height;}
        double& Cylinder_Radius()const{return Radius;}
        double& Cylinder_Height()const{return Height;}
        Cylinder(){cout<<"Constructor"<<endl;}
        Cylinder(double R,double H):Height{H},Radius{R}{cout<<"Constructor"<<endl;}
        ~Cylinder(){cout<<"Destructor"<<endl;}
};
int main(int, char*[])
{
    const Cylinder C1{};
    C1.Cylinder_Radius()=2;
    cout<<C1.Volume()<<endl<<C1.Cylinder_Radius()<<endl;
    return 0;
}
```
## Struct Binding

```cpp
#include<iostream>
struct Test
{
    public:
        int x{};
        int y{};
};
int main(int, char*[])
{
    Test Test_1{10,20};
    auto [x,y]=Test_1;
    std::cout<<x<<std::endl<<y<<std::endl;//10-20
    Test_1.x=40;
    Test_1.x=50;
    std::cout<<x<<std::endl<<y<<std::endl;//10-20
    return 0;
}
```
## Explicit Constructors

```cpp
#include "Company.hpp"
using namespace Mine;
bool Compare_Square(const Square &S1,const Square &S2)
{
    return (S1.Surface()>S2.Surface())?true:false;
}
int main(int, char*[])
{
    Mine::Square S1{33},S2{22};
    std::cout<<std::boolalpha;
    std::cout<<Compare_Square(S1,S2)<<std::endl;
    std::cout<<Compare_Square(S1,30)<<std::endl;//Explicit Error
    return 0;
}
class Square
{
private:
    double Side_Length{};
public:
    explicit Square(double Square_Side_Length=10);
    double Surface() const;
};
```
## Copy Constructors

```cpp
#include <iostream>
using namespace std;
struct Person
{
    int *Age{nullptr};
    string Name{};
    Person()=default;
    Person(const string &Person_Name,int Person_Age);
    Person(const Person &Copy_Person);
    ~Person();
    void Print();
};
Person::~Person(){}
Person::Person(const string &Person_Name,int Person_Age):Name{Person_Name},Age{new int(Person_Age)}{}
Person::Person(const Person &Copy_Person):Name{Copy_Person.Name},Age{new int(* Copy_Person.Age)}{}
void Person::Print()
{
    cout<<"- My Name Is "<<Name<<" I'm "<<*Age<<" Years Old .\n";
}
int main(int, char*[])
{
    Person P1{"Ahmed",11};
    Person P2{P1};
    P1.Print();
    P2.Print();
    return 0;
}
```
## Initializer list 

```CPP
#include <initializer_list>
#include <iostream>
class Point
{
public :
    Point(std::initializer_list<double> List)
    {
        std::cout<<"Default Constructor"<<std::endl;
        for(size_t Counter{};Counter<List.size();++Counter)
        {
            std::cout<<(Counter+1)<<" - "<<List.begin()[Counter]<<std::endl;
        }
        m_x=List.begin()[0];
        m_y=List.begin()[1];
    }
    void Print(void)
    {
        std::cout<<"["<<m_x<<","<<m_y<<"]"<<std::endl;
    }
    double m_y{};
    double m_x{};
};
int main()
{
    Point X{1.1,2.2,3.3};
    X.Print();
    return 0;
}
```
## Static Members

```cpp
#include <iostream>
#include <ostream>
class Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{++Counter;}
    void Print(void)const{++Counter;std::cout<<"Objects = "<<Point::Counter<<std::endl;}
    ~Point(){--Counter;}
    static size_t Counter;
private:
    double m_y{};
    double m_x{};
};
size_t Point::Counter{};
int main()
{
    Point X{1,2};
    Point X2{1,2};
    std::cout<<"Objects = "<<Point::Counter<<std::endl;
    return 0;
}
/////////////////////////////////////////////////
#include <iostream>
#include <ostream>
class Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{++Counter;}
    void Print(void)const{++Counter;std::cout<<"Objects = "<<Point::Counter<<std::endl;}
    ~Point(){--Counter;}
    inline static size_t Counter{};//C++17
private:
    double m_y{};
    double m_x{};
};
int main()
{
    Point X{1,2};
    Point X2{1,2};
    std::cout<<"Objects = "<<Point::Counter<<std::endl;
    return 0;
}
///////////////////////////////////////////////
#include <iostream>
class Point
{
public :
    Point()=default;
    Point(double x,double y):m_x{x},m_y{y}{++Counter;}
    static void Print(void)
    {
        ++Counter;std::cout<<"Objects = "<<Point::Counter<<std::endl;
        //m_x++;//Error
    }
    ~Point(){--Counter;}
    inline static size_t Counter{};
private:
    double m_y{};
    double m_x{};
};
int main()
{
    Point X{1,2};
    Point X2{1,2};
    std::cout<<"Objects = "<<Point::Counter<<std::endl;
    return 0;
}
```
## Inline Keyword

```cpp
//.h file
char Variable_2='2';
void Function_2(void)
{
    printf("Hello World %c\n",Variable_2);
}
//.c file
void Function_2(void);
inline char Variable_1='1';
inline void Function_1(void)
{
    printf("Hello World %c\n",Variable_1);
}
//Main file
int main()
{
    Function_1();
    Function_2();
    return 0;
}
/////////////////////////////////////////////////
//Definition Of Class
class Dog;
```
# Smart Pointer <mark style="background: #FF5582A6;">(C++14)</mark>

## Traditional Way

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Nme):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor"<<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    string Name{"Default Name"};
};
int main()
{
    Dog &Dog_1=*new Dog("Abc");
    Dog_1.Print_Name();
    //delete &Dog_1;//No Destructor 
    return 0;
}

```
## Unique Pointer

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor"<<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    string Name{"Default Name"};
};
int main()
{
    unique_ptr<Dog> Dog_1{new Dog("abc")};
    Dog_1->Print_Name();
    unique_ptr<Dog> Dog_2=make_unique<Dog>("efg");
    Dog_2->Print_Name();
    //unique_ptr<Dog> Dog_3=Dog_1;//Cant Copy Uniqe Pointer
    unique_ptr<Dog> Dog_4=move(Dog_1);//Move Ownership of Uniqe Pointer
    Dog_4->Print_Name();
    Dog_4.reset();//Release Memory Manual
    return 0;
}
```
## Arrays Using Unique Pointer

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor"<<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    string Name{"Default Name"};
};
int main()
{
    Dog Array_1[3]{Dog("A"),Dog("B"),Dog("C")};
    Dog *Array_2=new Dog[3]{Dog("A"),Dog("B"),Dog("C")};
    unique_ptr<Dog[]> Array_3=unique_ptr<Dog[]>(new Dog[3]{Dog("A"),Dog("B"),Dog("C")});
    unique_ptr<Dog[]> Array_4=make_unique<Dog[]>(3);
    Array_1[0].Print_Name();
    Array_2[0].Print_Name();
    Array_3[0].Print_Name();
    Array_4[0].Print_Name();
    delete[] Array_2;
    return 0;
}
```
## Shared Pointers

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor"<<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    string Name{"Default Name"};
};
struct Point {
    Point (double x, double y) : m_x(x), m_y(y) {}
    ~Point(){
    }
    double m_x{};
    double m_y{};
};
int main()
{
    shared_ptr<Dog> Dog_1{new Dog("DOG 1")};
    shared_ptr<Dog> Dog_2{new Dog("DOG 2")};
    shared_ptr<Dog> Dog_5{make_shared<Dog>("DOG 5")};
    shared_ptr<Dog> Dog_3{Dog_2};
    shared_ptr<Dog> Dog_4{};
    Dog_1->Print_Name();
    cout<<Dog_1.use_count()<<endl;
    Dog_1=Dog_2;
    Dog_1->Print_Name();
    Dog_1.reset();
    cout<<Dog_1.use_count()<<endl;
    cout<<Dog_4.use_count()<<endl;
    cout<<Dog_2.get()<<endl;
    return 0;
}
```
## From Unique To Shared

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor"<<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    string Name{"Default Name"};
};
int main()
{
    unique_ptr<Dog> Dog_1{make_unique<Dog>("Dog 1")};
    unique_ptr<Dog> Dog_2{new Dog("Dog 2")};
    shared_ptr<Dog> Dog_1_S{move(Dog_1)};
    shared_ptr<Dog> Dog_2_S{move(Dog_2)};
    //unique_ptr<Dog> Dog_3{move(Dog_1_S)};
    shared_ptr<Dog> Dog_3{Dog_1_S};
    cout<<Dog_1.get()<<endl;
    cout<<Dog_1_S.use_count()<<endl;
    return 0;
}
```
## Arrays Using Shared Pointer

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
private:
    string Name{"Default Name"};
};
int main()
{
    shared_ptr<Dog[]> Dog_Array{new Dog[] {Dog("Dog_1"),Dog("Dog_2")}};
    Dog_Array[1].Print_Name();
    Dog_Array[0]=Dog("Dog_0");
    Dog_Array[0].Print_Name();
    return 0;
}
```

## Pass Shared Pointer

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    friend void Print_Name(Dog &Object);
private:
    string Name{"Default Name"};
};
void Print_Name(Dog &Object){cout<<Object.Name<<endl;}
void Print_Names(shared_ptr<Dog[]> &PTR)
{
    for(size_t Counter{};Counter<2;++Counter)
    {
        Print_Name(PTR[Counter]);
    }
}
int main()
{
    shared_ptr<Dog[]> Dog_Array{new Dog[] {Dog("Dog_1"),Dog("Dog_2")}};
    Print_Name(Dog_Array[0]);
    Print_Names(Dog_Array);
    return 0;
}
```
## Weak Pointer

```cpp
#include <iostream>
#include <memory>
using namespace std;
class Dog
{
public:
    Dog()=default;
    Dog(const string &Dog_Name):Name{Dog_Name}{cout<<"Constructor"<<endl;}
    ~Dog(){cout<<"Destractor" <<endl;}
    void Print_Name(){cout<<Name<<endl;}
    string Name{"Default Name"};
    //shared_ptr<Dog> Friend{};
    weak_ptr<Dog> Friend{};
    void Change_Friend_Name(const string &Name)
    {
        if(!Friend.expired())
        {
            shared_ptr Edit_Friend{Friend.lock()};
            Edit_Friend->Name=Name;
        }
    }
};
int main()
{
    shared_ptr<Dog> Dog_1 = make_shared<Dog>("Dog 1");
    shared_ptr<Dog> Dog_2 = make_shared<Dog>("Dog 2");
    Dog_1->Friend=Dog_2;
    Dog_2->Friend=Dog_1;
    Dog_1->Print_Name();
    Dog_2->Print_Name();
    Dog_1->Change_Friend_Name("Dog 3");
    Dog_1->Print_Name();
    Dog_2->Print_Name();
    return 0;
}
```