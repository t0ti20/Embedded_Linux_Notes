# Polymorphism :

## Example :
## Override :

```cpp
#include <iostream>
using namespace std;
class Shape
{
public:
    Shape()=default;
    Shape(const string &Shape_Description):Description{Shape_Description}{}
    virtual void Draw(void){cout<<"Painting Shape Description : "<<Description<<endl;}
private:
    string Description{"Default"};
};
class Oval : public Shape
{
public:
    Oval()=default;
    Oval(double Oval_X_Radius,double Oval_Y_Radius,const string &Oval_Description):
    Description{Oval_Description},
    X_Radius{Oval_X_Radius},
    Y_Radius{Oval_Y_Radius}{}
    virtual void Draw(void){cout<<"Painting Oval Description : "<<Description<<" X_Radius : "<<X_Radius<<" Y_Radius : "<<Y_Radius<<endl;}
protected:
    double X_Radius{};
    double Y_Radius{};
    string Description{"Default"};
};
class Circle : public Oval
{
public:
    Circle()=default;
    Circle(double Circle_Radius,const string &Circle_Description):Oval{Circle_Radius,Circle_Radius,Circle_Description}{}
    virtual void Draw(void){cout<<"Painting Circle Description : "<<Description<<" Radius : "<<X_Radius<<endl;}
};
int main()
{

    Shape Shape_1{"Shape"};
    Oval Oval_1{10,20,"Oval"};
    Circle Circle_1{10,"Circle"};
    Shape *Shape_Pointer[3]{&Shape_1,&Oval_1,&Circle_1};
    Shape_Pointer[0]->Draw();
    Shape_Pointer[1]->Draw();
    Shape_Pointer[2]->Draw();
    return 0;
}
```

---

## Final :

```cpp
#include <iostream>
using namespace std;
class Base //final //error
{
public:
    virtual void Say_Hello()const /* final */{cout<<"Hello Base"<<endl;}
};
class Drived final: public Base
{
public:
    virtual void Say_Hello()const final{cout<<"Hello Drived"<<endl;}
};
Base Base_Class;
Drived Drived_Class;
int main()
{
    Base *Array[]{&Base_Class,&Drived_Class};
    Array[0]->Say_Hello();
    Array[1]->Say_Hello();
    return 0;
}
```
# Inheritance

### Syntax

```cpp
class Grandpa
{
public:
    int Grandpa_Public{};
protected:
    int Grandpa_Protected{};
private:
    int Grandpa_Private{};
};
class Father : private Grandpa
{
public:
    using Grandpa::Grandpa_Protected;
    int Father_Public{};
protected:
    using Grandpa::Grandpa_Public;
    int Father_Protected{};
private:
    int Father_Private{};
};
class Son : public Father
{
public:
    int Father_Public{};
protected:
    int Father_Protected{};
private:
    int Father_Private{};
};
int main() 
{
	Grandpa Grandpa_Object{};
	Father Father_Object{};
	Son Son_Object{};
	Father_Object.Grandpa_Protected=10;
	return 0;
}

```

### Copy Constructor

```cpp
#include <iostream>
#include <string>
using namespace std;
class Grandpa
{
public:
    Grandpa()=default;
    Grandpa(const Grandpa &Grandpa_Object):Name{Grandpa_Object.Name}{};
    Grandpa(string Grandpa_Name):Name{Grandpa_Name}{}
    void Print_Info(void){cout<<"Grandpa Name : "<<Name<<endl<<endl;}
    string Name{"Default Grandpa"};
};
class Father : protected Grandpa
{
public:
    Father()=default;
    Father(string Father_Name):Name{Father_Name}{}
    Father(const Father &Father_Object):Grandpa(Father_Object),Name{Father_Object.Name}{};
    Father(string Father_Name,string Grandpa_Name):Name{Father_Name},Grandpa{Grandpa_Name}{}
    void Print_Info(void){cout<<"Grandpa Name : "<<Grandpa::Name<<endl<<"Father Name : "<<Name<<endl<<endl;}
    string Name{"Default Father"};
};
class Son : protected Father
{
public:
    Son()=default;
    Son(string Son_Name):Name{Son_Name}{}
    Son(const Son &Son_Object):Father(Son_Object),Name{Son_Object.Name}{};
    Son(string Son_Name,string Father_Name):Name{Son_Name},Father{Father_Name}{}
    Son(string Son_Name,string Father_Name,string Grandpa_Name):Name{Son_Name},Father{Father_Name,Grandpa_Name}{}
    void Print_Info(void){cout<<"Grandpa Name : "<<Grandpa::Name<<endl<<"Father Name : "<<Father::Name<<endl<<"Son Name : "<<Name<<endl<<endl;}
private:
    string Name{"Default Son"};
};
int main() 
{
    Grandpa Grandpa_Object{"Abdulaziz"};
    Father Father_Object{"Sayed","Abdulaziz"};
    Son Son_Object{"Khaled","El-Sayed","Abdulaziz"};
    Grandpa_Object.Print_Info();
    Father_Object.Print_Info();
    Son_Object.Print_Info();

    Father Father_Object_2{Father_Object};
    Father_Object_2.Print_Info();

    return 0;
}
```

___

___
# Abstract Classes and Final Classifier :

An abstract class, often referred to as an interface, outlines the behavior or capabilities of a C++ class without specifying its actual implementation. The primary purpose of an abstract class is to act as a blueprint for other classes in a hierarchy. Abstract classes cannot be instantiated, serving solely as an interface for derived classes. This implies that functions within an abstract class must be overridden by concrete (non-abstract) derived classes. However, if you want to prevent further overriding of a particular function, you can use the `final` specifier, as demonstrated in the following example.

In C++, a class is designated as abstract by declaring at least one of its functions as a pure virtual function. A pure virtual function lacks implementation in the abstract class and mandates implementation by any concrete derived class.

### Example Code: Abstract Classes

```CPP
#include <iostream>

using namespace std;

//Abstracted Class Cuz It Have Pure virtual Function
class Shape 
{
  string Shape_Color;
public:
  //Constructor to set the color of the shape
  Shape(string Color) : Shape_Color(Color) {}
  //Pure virtual function to define the 'Area' interface
  virtual void Area() = 0;
  virtual void Display() final
  {
    cout << "This Is The Shape Display" << endl;
  }
};

class Rectangle : public Shape 
{
  int Rectangle_Length;
  int Rectangle_Width;
public:
	//Constructor to initialize dimensions and color
	Rectangle(int Length, int Width, string Color) : Shape(Color)
	{
		Rectangle_Length = Length;
		Rectangle_Width = Width;
	}
	//Implementation of the pure virtual function 'Area' from the base class
	void Area() override 
	{
		cout << "This Is The Rectangle Area" << endl;
	}
	//Additional function specific to the Rectangle class
	void Area2() 
	{
		cout << "This Is The Rectangle Area2" << endl;
	}
};

int main() 
{
  // Using a pointer to the base class to demonstrate polymorphism
  Shape *Shape_Ptr;
  Rectangle Rectangle_1{10, 20, "Red"};
  Shape_Ptr = &Rectangle_1;
  //'Area' function is polymorphically overridden in the Rectangle class
  Shape_Ptr->Area();
  Shape_Ptr->Display();
}
```

___
# Friend Function and Friend Class :
### Friend Function:

A friend function of a class is defined outside that class's scope, but it has the right to access all private and protected members of the class. The prototypes for friend functions appear in the class definition. Friend functions are not member functions.

```cpp
#include <iostream>
using namespace std;
class Person 
{
friend void New_Display(Person);
private:
  string Person_Name;
  string Person_Gender;
  float Person_Age;
public:
  Person(){}
  Person(string Name,string Gender,float Age)
  :Person_Name{Name},Person_Gender{Gender},Person_Age{Age}
  {}
  void Display()
  {
    cout << "This Is The Person Display" << endl;
  }
};
void New_Display(Person Current_Person)
{
  cout << "This Is The Public Display " << Current_Person.Person_Name << endl;
}
int main() 
{
  Person Person_1{"Ahmed","Male",22};
  New_Display(Person_1);
}
```
### Friend Class:

Just like friend functions, we can also have a friend class. A friend class can access private and protected members of the class to which it is a friend. Note that the friendship is not mutual unless we make it so. The friendship of the class is not inherited. This means that as class B is a friend of class A, it will not be a friend of the subclasses of class A.

```cpp
#include <iostream>
using namespace std;
class Person 
{
friend class Engineer;
private:
  string Person_Name;
  string Person_Gender;
  float Person_Age;
public:
  Person(){}
  Person(string Name,string Gender,float Age):Person_Name{Name},Person_Gender{Gender},Person_Age{Age}{}
  void Display()
  {
    cout << "This Is The Person Display" << endl;
  }
};
class Engineer
{
private:
public:
  void Print_Engineer(Person Current_Engineer)
  {
    cout << "This Is The Engineer Display " << Current_Engineer.Person_Name << endl;
  }
};
int main() 
{
  Person Person_1{"Ahmed","Male",22};
  Engineer Engineer_1;
  Engineer_1.Print_Engineer(Person_1);
}
```
